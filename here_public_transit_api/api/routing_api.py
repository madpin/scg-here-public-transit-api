# coding: utf-8

"""
    Routing API v8

    A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.  # noqa: E501

    OpenAPI spec version: 8.52.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from here_public_transit_api.api_client import ApiClient


class RoutingApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def calculate_routes(self, transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate routes via GET  # noqa: E501

        Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculate_routes(transport_mode, origin, destination, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param Waypoint origin: A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param Waypoint destination: A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param list[Waypoint] via: A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param Time arrival_time: Specifies the time of arrival as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`). The requested time is converted to the local time at destination. When the optional timezone offset is not specified, time is assumed to be local. All `Time` values in the response are returned in the timezone of each location.  Note : The following features do not support the arrivalTime parameter: * EV Routing * Route Handle * Route Import 
        :param RoutingMode routing_mode: Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `privateBus`   - `scooter`   - `taxi` 
        :param int alternatives: Number of alternative routes to return aside from the optimal route.
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool ev_make_reachable:
        :param str ev_preferred_brands:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param list[CustomizationHRN] customizations: Specifies a list of customizations to be used. The data provided by these customizations either replaces or augments the standard HERE map data. The provided credentials must authorize access to all of the customizations specified.  **Alpha**: This API is in development. It may not be stable and is subject to change. 
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculate_routes_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs)  # noqa: E501
        else:
            (data) = self.calculate_routes_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs)  # noqa: E501
            return data

    def calculate_routes_with_http_info(self, transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate routes via GET  # noqa: E501

        Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculate_routes_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param Waypoint origin: A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param Waypoint destination: A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param list[Waypoint] via: A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param Time arrival_time: Specifies the time of arrival as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`). The requested time is converted to the local time at destination. When the optional timezone offset is not specified, time is assumed to be local. All `Time` values in the response are returned in the timezone of each location.  Note : The following features do not support the arrivalTime parameter: * EV Routing * Route Handle * Route Import 
        :param RoutingMode routing_mode: Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `privateBus`   - `scooter`   - `taxi` 
        :param int alternatives: Number of alternative routes to return aside from the optimal route.
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool ev_make_reachable:
        :param str ev_preferred_brands:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param list[CustomizationHRN] customizations: Specifies a list of customizations to be used. The data provided by these customizations either replaces or augments the standard HERE map data. The provided credentials must authorize access to all of the customizations specified.  **Alpha**: This API is in development. It may not be stable and is subject to change. 
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_mode', 'origin', 'destination', 'ev_free_flow_speed_table', 'via', 'departure_time', 'arrival_time', 'routing_mode', 'alternatives', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'ev_make_reachable', 'ev_preferred_brands', 'pedestrian_speed', 'x_request_id', 'scooter_allow_highway', 'currency', 'customizations', 'taxi_allow_drive_through_taxi_roads', 'tolls_transponders', 'tolls_vignettes', 'tolls_summaries', 'tolls_vehicle_category', 'tolls_emission_type', 'max_speed_on_segment', 'traffic_override_flow_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculate_routes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `calculate_routes`")  # noqa: E501
        # verify the required parameter 'origin' is set
        if ('origin' not in params or
                params['origin'] is None):
            raise ValueError("Missing the required parameter `origin` when calling `calculate_routes`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `calculate_routes`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `calculate_routes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'origin' in params:
            query_params.append(('origin', params['origin']))  # noqa: E501
        if 'destination' in params:
            query_params.append(('destination', params['destination']))  # noqa: E501
        if 'via' in params:
            query_params.append(('via', params['via']))  # noqa: E501
            collection_formats['via'] = 'multi'  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'arrival_time' in params:
            query_params.append(('arrivalTime', params['arrival_time']))  # noqa: E501
        if 'routing_mode' in params:
            query_params.append(('routingMode', params['routing_mode']))  # noqa: E501
        if 'alternatives' in params:
            query_params.append(('alternatives', params['alternatives']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'ev_make_reachable' in params:
            query_params.append(('ev[makeReachable]', params['ev_make_reachable']))  # noqa: E501
        if 'ev_preferred_brands' in params:
            query_params.append(('ev[preferredBrands]', params['ev_preferred_brands']))  # noqa: E501
        if 'pedestrian_speed' in params:
            query_params.append(('pedestrian[speed]', params['pedestrian_speed']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'customizations' in params:
            query_params.append(('customizations', params['customizations']))  # noqa: E501
            collection_formats['customizations'] = 'multi'  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501
        if 'tolls_transponders' in params:
            query_params.append(('tolls[transponders]', params['tolls_transponders']))  # noqa: E501
        if 'tolls_vignettes' in params:
            query_params.append(('tolls[vignettes]', params['tolls_vignettes']))  # noqa: E501
        if 'tolls_summaries' in params:
            query_params.append(('tolls[summaries][]', params['tolls_summaries']))  # noqa: E501
            collection_formats['tolls[summaries][]'] = 'multi'  # noqa: E501
        if 'tolls_vehicle_category' in params:
            query_params.append(('tolls[vehicleCategory]', params['tolls_vehicle_category']))  # noqa: E501
        if 'tolls_emission_type' in params:
            query_params.append(('tolls[emissionType]', params['tolls_emission_type']))  # noqa: E501
        if 'max_speed_on_segment' in params:
            query_params.append(('maxSpeedOnSegment', params['max_speed_on_segment']))  # noqa: E501
        if 'traffic_override_flow_duration' in params:
            query_params.append(('traffic[overrideFlowDuration]', params['traffic_override_flow_duration']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/routes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def calculate_routes_post(self, transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate routes via POST  # noqa: E501

        Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  At the moment, only select parameters are permitted in the POST payload. In particular, those parameters that due to request size may be limited in the query string. See the request body section below. These parameters can be provided either in the query string or in the POST body. However, if a parameter is provided in both, the request will fail. All other parameters can only be provided in the query string at the moment.  Post body size limit is 10MiB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculate_routes_post(transport_mode, origin, destination, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param Waypoint origin: A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param Waypoint destination: A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param CalculateRoutesPostParameters body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param list[Waypoint] via: A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param Time arrival_time: Specifies the time of arrival as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`). The requested time is converted to the local time at destination. When the optional timezone offset is not specified, time is assumed to be local. All `Time` values in the response are returned in the timezone of each location.  Note : The following features do not support the arrivalTime parameter: * EV Routing * Route Handle * Route Import 
        :param RoutingMode routing_mode: Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `privateBus`   - `scooter`   - `taxi` 
        :param int alternatives: Number of alternative routes to return aside from the optimal route.
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool ev_make_reachable:
        :param str ev_preferred_brands:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param list[CustomizationHRN] customizations: Specifies a list of customizations to be used. The data provided by these customizations either replaces or augments the standard HERE map data. The provided credentials must authorize access to all of the customizations specified.  **Alpha**: This API is in development. It may not be stable and is subject to change. 
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.calculate_routes_post_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs)  # noqa: E501
        else:
            (data) = self.calculate_routes_post_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs)  # noqa: E501
            return data

    def calculate_routes_post_with_http_info(self, transport_mode, origin, destination, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate routes via POST  # noqa: E501

        Calculates a route using a generic vehicle/pedestrian mode, e.g. car, truck, pedestrian, etc...  At the moment, only select parameters are permitted in the POST payload. In particular, those parameters that due to request size may be limited in the query string. See the request body section below. These parameters can be provided either in the query string or in the POST body. However, if a parameter is provided in both, the request will fail. All other parameters can only be provided in the query string at the moment.  Post body size limit is 10MiB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.calculate_routes_post_with_http_info(transport_mode, origin, destination, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param Waypoint origin: A location defining the origin of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param Waypoint destination: A location defining the destination of the trip.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options:  * `stopDuration`: desired duration for the stop, in seconds. The section arriving at this   via waypoint will have a `wait` post action reflecting the stopping time. The   consecutive section will start at the arrival time of the former section + stop   duration. * `passThrough`: option is not supported for 'destination'.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param CalculateRoutesPostParameters body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param list[Waypoint] via: A location defining a via waypoint.  A via waypoint is a location between origin and destination. The route will do a stop at the via waypoint.  Multiple waypoints can also be specified using multiple via parameters like `via=...&via=...`, in which case the route will traverse these waypoints sequentially in the order specified in the request.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported. * `minCourseDistance`: int, meters. Instructs the routing service to try to find a route that avoids actions for the indicated distance.   For example, if the origin is determined by a moving vehicle, the user might not have time to react to early actions. * `customizationIndex`: int. Specifies the zero-based index into the list of customizations   specified in the `customizations` parameter. The customization at that index must be an   Extension Map.   Providing a `customizationIndex` indicates the this waypoint is located within that   Extension Map.   **Alpha**: This customization API parameter is in development. It may not be stable and is subject to change. * `segmentIdHint`: string. Causes the router to try and match to the specified segment.   Waypoint coordinates need to be on the segment, otherwise waypoint will be matched ignoring the segment hint   This parameter can be used when the waypoint is too close to more than one segment to force matching to a specific one. * `onRoadThreshold`: int, meters. allows specifying a distance within which   the waypoint could be considered as being on a highway/bridge/tunnel/sliproad.   Within this threshold, the attributes of the segments do not impact the matching.   Outside the threshold only segments which aren't one of highway/bridge/tunnel/sliproad can be matched.  Supported waypoint options: * `stopDuration`: desired duration for the stop, in seconds. * `passThrough`: boolean. Asks the router to avoid the following during route calculation:   + Introducing a stop at the waypoint.   + Splitting the route into sections.   + Changing the direction of travel.    Following scenarios are not supported for `passThrough` parameter:   + Setting both `stopDuration` to a value greater than 0 and `passThrough=true`.   + Setting `passThrough=true` for `origin` or `destination` of a route.   The default value is `false`.  Notes:  * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param Time arrival_time: Specifies the time of arrival as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`). The requested time is converted to the local time at destination. When the optional timezone offset is not specified, time is assumed to be local. All `Time` values in the response are returned in the timezone of each location.  Note : The following features do not support the arrivalTime parameter: * EV Routing * Route Handle * Route Import 
        :param RoutingMode routing_mode: Specifies which optimization is applied during route calculation.  * `fast`: Route calculation from start to destination optimized by travel time. In many   cases, the route returned by the `fast` mode may not be the route with the fastest   possible travel time. For example, the routing service may favor a route that remains on   a highway, even if a faster travel time can be achieved by taking a detour or shortcut   through an inconvenient side road. * `short`: Route calculation from start to destination disregarding any speed information.   In this mode, the distance of the route is minimized, while keeping the route sensible.   This includes, for example, penalizing turns. Because of that, the resulting route will   not necessarily be the one with minimal distance.  Notes: * The following Transport modes only support `fast` routingMode   - `bicycle`   - `bus`   - `pedestrian`   - `privateBus`   - `scooter`   - `taxi` 
        :param int alternatives: Number of alternative routes to return aside from the optimal route.
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool ev_make_reachable:
        :param str ev_preferred_brands:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param list[CustomizationHRN] customizations: Specifies a list of customizations to be used. The data provided by these customizations either replaces or augments the standard HERE map data. The provided credentials must authorize access to all of the customizations specified.  **Alpha**: This API is in development. It may not be stable and is subject to change. 
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_mode', 'origin', 'destination', 'ev_free_flow_speed_table', 'body', 'x_request_id', 'via', 'departure_time', 'arrival_time', 'routing_mode', 'alternatives', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'ev_make_reachable', 'ev_preferred_brands', 'pedestrian_speed', 'scooter_allow_highway', 'currency', 'customizations', 'taxi_allow_drive_through_taxi_roads', 'tolls_transponders', 'tolls_vignettes', 'tolls_summaries', 'tolls_vehicle_category', 'tolls_emission_type', 'max_speed_on_segment', 'traffic_override_flow_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method calculate_routes_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `calculate_routes_post`")  # noqa: E501
        # verify the required parameter 'origin' is set
        if ('origin' not in params or
                params['origin'] is None):
            raise ValueError("Missing the required parameter `origin` when calling `calculate_routes_post`")  # noqa: E501
        # verify the required parameter 'destination' is set
        if ('destination' not in params or
                params['destination'] is None):
            raise ValueError("Missing the required parameter `destination` when calling `calculate_routes_post`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `calculate_routes_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'origin' in params:
            query_params.append(('origin', params['origin']))  # noqa: E501
        if 'destination' in params:
            query_params.append(('destination', params['destination']))  # noqa: E501
        if 'via' in params:
            query_params.append(('via', params['via']))  # noqa: E501
            collection_formats['via'] = 'multi'  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'arrival_time' in params:
            query_params.append(('arrivalTime', params['arrival_time']))  # noqa: E501
        if 'routing_mode' in params:
            query_params.append(('routingMode', params['routing_mode']))  # noqa: E501
        if 'alternatives' in params:
            query_params.append(('alternatives', params['alternatives']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'ev_make_reachable' in params:
            query_params.append(('ev[makeReachable]', params['ev_make_reachable']))  # noqa: E501
        if 'ev_preferred_brands' in params:
            query_params.append(('ev[preferredBrands]', params['ev_preferred_brands']))  # noqa: E501
        if 'pedestrian_speed' in params:
            query_params.append(('pedestrian[speed]', params['pedestrian_speed']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'customizations' in params:
            query_params.append(('customizations', params['customizations']))  # noqa: E501
            collection_formats['customizations'] = 'multi'  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501
        if 'tolls_transponders' in params:
            query_params.append(('tolls[transponders]', params['tolls_transponders']))  # noqa: E501
        if 'tolls_vignettes' in params:
            query_params.append(('tolls[vignettes]', params['tolls_vignettes']))  # noqa: E501
        if 'tolls_summaries' in params:
            query_params.append(('tolls[summaries][]', params['tolls_summaries']))  # noqa: E501
            collection_formats['tolls[summaries][]'] = 'multi'  # noqa: E501
        if 'tolls_vehicle_category' in params:
            query_params.append(('tolls[vehicleCategory]', params['tolls_vehicle_category']))  # noqa: E501
        if 'tolls_emission_type' in params:
            query_params.append(('tolls[emissionType]', params['tolls_emission_type']))  # noqa: E501
        if 'max_speed_on_segment' in params:
            query_params.append(('maxSpeedOnSegment', params['max_speed_on_segment']))  # noqa: E501
        if 'traffic_override_flow_duration' in params:
            query_params.append(('traffic[overrideFlowDuration]', params['traffic_override_flow_duration']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/routes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_routes_by_handle(self, route_handle, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Get route by handle via GET  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Disclaimer: A route handle is not suitable for persistent route storage! It can be invalidated at any time.**  A route handle encodes a previously calculated route. A route can be decoded from a handle as long as the service uses the same map data and encoding that were used when retrieving the handle.  Thus it is suitable for caching routes compactly. It can be used to retrieve updated traffic information or other data along the route. However, a user should be prepared to recalculate the route when decoding the handle fails.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.  Please refer to the developers' guide for more information and examples.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_routes_by_handle(route_handle, transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str route_handle: Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information.  (required)
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param Waypoint origin: A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param str rerouting_mode:
        :param int rerouting_last_traveled_section_index:
        :param int rerouting_traveled_distance_on_last_section:
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_routes_by_handle_with_http_info(route_handle, transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
        else:
            (data) = self.get_routes_by_handle_with_http_info(route_handle, transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
            return data

    def get_routes_by_handle_with_http_info(self, route_handle, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Get route by handle via GET  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Disclaimer: A route handle is not suitable for persistent route storage! It can be invalidated at any time.**  A route handle encodes a previously calculated route. A route can be decoded from a handle as long as the service uses the same map data and encoding that were used when retrieving the handle.  Thus it is suitable for caching routes compactly. It can be used to retrieve updated traffic information or other data along the route. However, a user should be prepared to recalculate the route when decoding the handle fails.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.  Please refer to the developers' guide for more information and examples.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_routes_by_handle_with_http_info(route_handle, transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str route_handle: Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information.  (required)
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param Waypoint origin: A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param str rerouting_mode:
        :param int rerouting_last_traveled_section_index:
        :param int rerouting_traveled_distance_on_last_section:
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['route_handle', 'transport_mode', 'ev_free_flow_speed_table', 'origin', 'departure_time', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'pedestrian_speed', 'x_request_id', 'scooter_allow_highway', 'currency', 'rerouting_mode', 'rerouting_last_traveled_section_index', 'rerouting_traveled_distance_on_last_section', 'taxi_allow_drive_through_taxi_roads', 'tolls_transponders', 'tolls_vignettes', 'tolls_summaries', 'tolls_vehicle_category', 'tolls_emission_type', 'max_speed_on_segment', 'traffic_override_flow_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_routes_by_handle" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'route_handle' is set
        if ('route_handle' not in params or
                params['route_handle'] is None):
            raise ValueError("Missing the required parameter `route_handle` when calling `get_routes_by_handle`")  # noqa: E501
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `get_routes_by_handle`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `get_routes_by_handle`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'route_handle' in params:
            path_params['routeHandle'] = params['route_handle']  # noqa: E501

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'origin' in params:
            query_params.append(('origin', params['origin']))  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'pedestrian_speed' in params:
            query_params.append(('pedestrian[speed]', params['pedestrian_speed']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'rerouting_mode' in params:
            query_params.append(('rerouting[mode]', params['rerouting_mode']))  # noqa: E501
        if 'rerouting_last_traveled_section_index' in params:
            query_params.append(('rerouting[lastTraveledSectionIndex]', params['rerouting_last_traveled_section_index']))  # noqa: E501
        if 'rerouting_traveled_distance_on_last_section' in params:
            query_params.append(('rerouting[traveledDistanceOnLastSection]', params['rerouting_traveled_distance_on_last_section']))  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501
        if 'tolls_transponders' in params:
            query_params.append(('tolls[transponders]', params['tolls_transponders']))  # noqa: E501
        if 'tolls_vignettes' in params:
            query_params.append(('tolls[vignettes]', params['tolls_vignettes']))  # noqa: E501
        if 'tolls_summaries' in params:
            query_params.append(('tolls[summaries][]', params['tolls_summaries']))  # noqa: E501
            collection_formats['tolls[summaries][]'] = 'multi'  # noqa: E501
        if 'tolls_vehicle_category' in params:
            query_params.append(('tolls[vehicleCategory]', params['tolls_vehicle_category']))  # noqa: E501
        if 'tolls_emission_type' in params:
            query_params.append(('tolls[emissionType]', params['tolls_emission_type']))  # noqa: E501
        if 'max_speed_on_segment' in params:
            query_params.append(('maxSpeedOnSegment', params['max_speed_on_segment']))  # noqa: E501
        if 'traffic_override_flow_duration' in params:
            query_params.append(('traffic[overrideFlowDuration]', params['traffic_override_flow_duration']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/routes/{routeHandle}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_routes_by_handle_post(self, transport_mode, ev_free_flow_speed_table, route_handle, **kwargs):  # noqa: E501
        """Get route by handle via POST  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Disclaimer: A route handle is not suitable for persistent route storage! It can be invalidated at any time.**  A route handle encodes a previously calculated route. A route can be decoded from a handle as long as the service uses the same map data and encoding that were used when retrieving the handle.  Thus it is suitable for caching routes compactly. It can be used to retrieve updated traffic information or other data along the route. However, a user should be prepared to recalculate the route when decoding the handle fails.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.  Parameters can be provided either in the query string or some selected ones also in the POST body. If a parameter is provided in both, the request will fail.  Post body size limit is 10MiB.  Please refer to the developers' guide for more information and examples.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_routes_by_handle_post(transport_mode, ev_free_flow_speed_table, route_handle, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param str route_handle: Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information.  (required)
        :param GetRoutesByHandlePostParameters body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param Waypoint origin: A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param str rerouting_mode:
        :param int rerouting_last_traveled_section_index:
        :param int rerouting_traveled_distance_on_last_section:
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_routes_by_handle_post_with_http_info(transport_mode, ev_free_flow_speed_table, route_handle, **kwargs)  # noqa: E501
        else:
            (data) = self.get_routes_by_handle_post_with_http_info(transport_mode, ev_free_flow_speed_table, route_handle, **kwargs)  # noqa: E501
            return data

    def get_routes_by_handle_post_with_http_info(self, transport_mode, ev_free_flow_speed_table, route_handle, **kwargs):  # noqa: E501
        """Get route by handle via POST  # noqa: E501

        Decodes and returns a route from a previously calculated route handle.  **Disclaimer: A route handle is not suitable for persistent route storage! It can be invalidated at any time.**  A route handle encodes a previously calculated route. A route can be decoded from a handle as long as the service uses the same map data and encoding that were used when retrieving the handle.  Thus it is suitable for caching routes compactly. It can be used to retrieve updated traffic information or other data along the route. However, a user should be prepared to recalculate the route when decoding the handle fails.  All parameters of the `/routes` endpoint are supported, except for `destination`, `via`, `alternatives` and `routingMode`. See also the `return` parameter of `/routes` endpoint.  The `origin` parameter can be provided to update the start of the previously calculated route.  The `transportMode` parameter does not have to match the transport mode previously used for route calculation. However, when using a different transport mode, the request may fail, e.g. when the route has road segments forbidden for the provided transport mode.  Parameters can be provided either in the query string or some selected ones also in the POST body. If a parameter is provided in both, the request will fail.  Post body size limit is 10MiB.  Please refer to the developers' guide for more information and examples.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_routes_by_handle_post_with_http_info(transport_mode, ev_free_flow_speed_table, route_handle, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param str route_handle: Route handle returned from a previous route calculation.  See `return` parameter of `/routes` endpoint for more information.  (required)
        :param GetRoutesByHandlePostParameters body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param Waypoint origin: A location defining the origin of the trip. The origin has to be located along the previously calculated route.  ## Format  Format: `Place[WaypointOptions]`  * Place: `{lat},{lng}[PlaceOptions]` * PlaceOptions: `;option1=value1;option2=value2...` * WaypointOptions: `!option1=value1!option2=value2...`  A waypoint consists of:  * Exactly one place * Optional settings for the place * Optional settings for the waypoint itself  Supported place options:  * `course`: int, degrees clock-wise from north. Indicating desired direction at the place.   E.g. `90` indicating `east`. Often combined with `radius` and/or `minCourseDistance` * `sideOfStreetHint`: `{lat},{lng}`. Indicating the side of the street that should be   used. E.g. if the location is to the left of the street, the router will prefer using   that side in case the street has dividers. E.g.   `52.511496,13.304140;sideOfStreetHint=52.512149,13.304076` indicates that the `north`   side of the street should be preferred. This option is required, if `matchSideOfStreet`   is set to `always`. * `matchSideOfStreet`: enum `[always, onlyIfDivided]`. Specifies how the location set by   `sideOfStreetHint` should be handled. Requires `sideOfStreetHint` to be specified as   well.   + `always` : Always prefer the given side of street.   + `onlyIfDivided`: Only prefer using side of street set by `sideOfStreetHint` in case     the street has dividers. This is the default behavior. * `nameHint`: string. Causes the router to look for the place with the most similar name.   This can e.g. include things like: `North` being used to differentiate between   interstates `I66 North` and `I66 South`, `Downtown Avenue` being used to correctly   select a residental street. * `radius`: int, meters. Asks the router to consider all places within the given radius as   potential candidates for route calculation. This can be either because it is not   important which place is used, or because it is unknown. Radius more than 200meter are   not supported.  Notes:  * `stopDuration` option is not supported for `origin`, contrary to `destination` and   `via` waypoints. * `passThrough`: option is not supported for 'origin'. * Non-structural reserved characters in options' values need to be properly percent-encoded.   Please refer to the developers' guide for more details. * `minCourseDistance`: While this parameter can be provided for compatibility reasons,   it will not affect the result of a getRoutesByHandle request. 
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param PedestrianSpeed pedestrian_speed: **Disclaimer: This parameter is currently in beta release, and is therefore subject to breaking changes. The parameter could be extracted to a separate API if speed capping for cars/trucks is introduced** Walking speed in meters per second. Influences the duration of walking segments along the route. 
        :param bool scooter_allow_highway:
        :param str currency: Currency code compliant to ISO 4217. Costs for the calculated route will be returned using this currency.  If not provided, the router will specify it. On a best-effort basis, the router will try to specify the costs in the local currency. 
        :param str rerouting_mode:
        :param int rerouting_last_traveled_section_index:
        :param int rerouting_traveled_distance_on_last_section:
        :param bool taxi_allow_drive_through_taxi_roads:
        :param str tolls_transponders:
        :param str tolls_vignettes:
        :param list[str] tolls_summaries:
        :param str tolls_vehicle_category:
        :param str tolls_emission_type:
        :param MaxSpeedOnSegment max_speed_on_segment: Specify new base speed for segment by value. Affects route selection and the ETA. Cannot increase base speed on segment. 
        :param int traffic_override_flow_duration:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_mode', 'ev_free_flow_speed_table', 'route_handle', 'body', 'x_request_id', 'origin', 'departure_time', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'pedestrian_speed', 'scooter_allow_highway', 'currency', 'rerouting_mode', 'rerouting_last_traveled_section_index', 'rerouting_traveled_distance_on_last_section', 'taxi_allow_drive_through_taxi_roads', 'tolls_transponders', 'tolls_vignettes', 'tolls_summaries', 'tolls_vehicle_category', 'tolls_emission_type', 'max_speed_on_segment', 'traffic_override_flow_duration']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_routes_by_handle_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `get_routes_by_handle_post`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `get_routes_by_handle_post`")  # noqa: E501
        # verify the required parameter 'route_handle' is set
        if ('route_handle' not in params or
                params['route_handle'] is None):
            raise ValueError("Missing the required parameter `route_handle` when calling `get_routes_by_handle_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'route_handle' in params:
            path_params['routeHandle'] = params['route_handle']  # noqa: E501

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'origin' in params:
            query_params.append(('origin', params['origin']))  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'pedestrian_speed' in params:
            query_params.append(('pedestrian[speed]', params['pedestrian_speed']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'currency' in params:
            query_params.append(('currency', params['currency']))  # noqa: E501
        if 'rerouting_mode' in params:
            query_params.append(('rerouting[mode]', params['rerouting_mode']))  # noqa: E501
        if 'rerouting_last_traveled_section_index' in params:
            query_params.append(('rerouting[lastTraveledSectionIndex]', params['rerouting_last_traveled_section_index']))  # noqa: E501
        if 'rerouting_traveled_distance_on_last_section' in params:
            query_params.append(('rerouting[traveledDistanceOnLastSection]', params['rerouting_traveled_distance_on_last_section']))  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501
        if 'tolls_transponders' in params:
            query_params.append(('tolls[transponders]', params['tolls_transponders']))  # noqa: E501
        if 'tolls_vignettes' in params:
            query_params.append(('tolls[vignettes]', params['tolls_vignettes']))  # noqa: E501
        if 'tolls_summaries' in params:
            query_params.append(('tolls[summaries][]', params['tolls_summaries']))  # noqa: E501
            collection_formats['tolls[summaries][]'] = 'multi'  # noqa: E501
        if 'tolls_vehicle_category' in params:
            query_params.append(('tolls[vehicleCategory]', params['tolls_vehicle_category']))  # noqa: E501
        if 'tolls_emission_type' in params:
            query_params.append(('tolls[emissionType]', params['tolls_emission_type']))  # noqa: E501
        if 'max_speed_on_segment' in params:
            query_params.append(('maxSpeedOnSegment', params['max_speed_on_segment']))  # noqa: E501
        if 'traffic_override_flow_duration' in params:
            query_params.append(('traffic[overrideFlowDuration]', params['traffic_override_flow_duration']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/routes/{routeHandle}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_route(self, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate a route from a sequence of trace points  # noqa: E501

        Creates a route from a sequence of trace points.  Post body size limit is 10MiB.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_route(transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param MatchTrace body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool scooter_allow_highway:
        :param bool taxi_allow_drive_through_taxi_roads:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
        else:
            (data) = self.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
            return data

    def import_route_with_http_info(self, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate a route from a sequence of trace points  # noqa: E501

        Creates a route from a sequence of trace points.  Post body size limit is 10MiB.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param MatchTrace body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool scooter_allow_highway:
        :param bool taxi_allow_drive_through_taxi_roads:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_mode', 'ev_free_flow_speed_table', 'body', 'x_request_id', 'departure_time', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'scooter_allow_highway', 'taxi_allow_drive_through_taxi_roads']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `import_route`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `import_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/geo+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_route(self, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate a route from a sequence of trace points  # noqa: E501

        Creates a route from a sequence of trace points.  Post body size limit is 10MiB.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_route(transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param MatchTrace body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool scooter_allow_highway:
        :param bool taxi_allow_drive_through_taxi_roads:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
        else:
            (data) = self.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, **kwargs)  # noqa: E501
            return data

    def import_route_with_http_info(self, transport_mode, ev_free_flow_speed_table, **kwargs):  # noqa: E501
        """Calculate a route from a sequence of trace points  # noqa: E501

        Creates a route from a sequence of trace points.  Post body size limit is 10MiB.  **Alpha**: This API is coming soon. It may not be stable and is subject to change.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_route_with_http_info(transport_mode, ev_free_flow_speed_table, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RouterMode transport_mode: Mode of transport to be used for the calculation of the route.  Note: `bus`, `privateBus`, and `taxi` modes are currently provided as Beta, with limited functionality. The API and behaviour may change drastically, or even become unsupported, without warning. Please refer to the developers' guide for more details.  (required)
        :param object ev_free_flow_speed_table: (required)
        :param MatchTrace body:
        :param str x_request_id: User-provided token that can be used to trace a request or a group of requests sent to the service.
        :param TimeWithAny departure_time: Specifies the time of departure as defined by either `date-time` or `full-date` `T` `partial-time` in `RFC 3339`, section 5.6 (for example, `2019-06-24T01:23:45`).  The requested time is converted to local time at origin. When the optional timezone offset is not specified, time is assumed to be local. The special value `any` can be used to indicate that time should not be taken into account during routing. If neither `departureTime` or `arrivalTime` are specified, current time at departure place will be used. All time values in the response are returned in the timezone of each location. 
        :param str avoid_features:
        :param str avoid_areas:
        :param str avoid_segments:
        :param str avoid_zone_categories:
        :param str avoid_zone_identifiers:
        :param str avoid_truck_road_types:
        :param str avoid_toll_transponders:
        :param str exclude_countries:
        :param Units units: Units of measurement used in guidance instructions. The default is `metric`. 
        :param list[str] lang: Specifies the list of preferred languages of the response. The first supported language from the list will be used for for the response. The value should comply with the [IETF BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). A list of supported languages for the routing service can be found in the dev guide https://developer.here.com/documentation/routing-api/dev_guide/topics/languages.html.  Note: If the first language in the list is not supported, an info notification will be generated with code `mainLanguageNotFound`. 
        :param list[ModelReturn] _return:
        :param list[Spans] spans: Defines which map content attributes are included in the response spans. For example, `attributes,length` will enable the fields `attributes` and `length` in the route response. For more information about the `countryCode` field, see https://www.iso.org/obp/ui/#search.  This parameter also requires that the `polyline` option is set within the `return` parameter. 
        :param str truck_shipped_hazardous_goods:
        :param int truck_gross_weight:
        :param int truck_weight_per_axle:
        :param str truck_weight_per_axle_group:
        :param int truck_height:
        :param int truck_width:
        :param int truck_length:
        :param str truck_tunnel_category:
        :param int truck_axle_count:
        :param int truck_trailer_axle_count:
        :param int truck_tires_count:
        :param str truck_category:
        :param int truck_trailer_count:
        :param int truck_hov_occupancy:
        :param str truck_license_plate:
        :param float truck_speed_cap:
        :param str truck_type:
        :param str vehicle_shipped_hazardous_goods:
        :param int vehicle_gross_weight:
        :param int vehicle_weight_per_axle:
        :param str vehicle_weight_per_axle_group:
        :param int vehicle_height:
        :param int vehicle_width:
        :param int vehicle_length:
        :param str vehicle_tunnel_category:
        :param int vehicle_axle_count:
        :param int vehicle_trailer_axle_count:
        :param int vehicle_tires_count:
        :param str vehicle_category:
        :param int vehicle_trailer_count:
        :param int vehicle_hov_occupancy:
        :param str vehicle_license_plate:
        :param float vehicle_speed_cap:
        :param str vehicle_type:
        :param object ev_traffic_speed_table:
        :param float ev_ascent:
        :param float ev_descent:
        :param float ev_auxiliary_consumption:
        :param float ev_initial_charge:
        :param float ev_max_charge:
        :param str ev_charging_curve:
        :param float ev_max_charging_voltage:
        :param float ev_max_charging_current:
        :param float ev_max_charge_after_charging_station:
        :param float ev_min_charge_at_charging_station:
        :param float ev_min_charge_at_first_charging_station:
        :param float ev_min_charge_at_destination:
        :param int ev_charging_setup_duration:
        :param str ev_connector_types:
        :param bool scooter_allow_highway:
        :param bool taxi_allow_drive_through_taxi_roads:
        :return: RouterRouteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transport_mode', 'ev_free_flow_speed_table', 'body', 'x_request_id', 'departure_time', 'avoid_features', 'avoid_areas', 'avoid_segments', 'avoid_zone_categories', 'avoid_zone_identifiers', 'avoid_truck_road_types', 'avoid_toll_transponders', 'exclude_countries', 'units', 'lang', '_return', 'spans', 'truck_shipped_hazardous_goods', 'truck_gross_weight', 'truck_weight_per_axle', 'truck_weight_per_axle_group', 'truck_height', 'truck_width', 'truck_length', 'truck_tunnel_category', 'truck_axle_count', 'truck_trailer_axle_count', 'truck_tires_count', 'truck_category', 'truck_trailer_count', 'truck_hov_occupancy', 'truck_license_plate', 'truck_speed_cap', 'truck_type', 'vehicle_shipped_hazardous_goods', 'vehicle_gross_weight', 'vehicle_weight_per_axle', 'vehicle_weight_per_axle_group', 'vehicle_height', 'vehicle_width', 'vehicle_length', 'vehicle_tunnel_category', 'vehicle_axle_count', 'vehicle_trailer_axle_count', 'vehicle_tires_count', 'vehicle_category', 'vehicle_trailer_count', 'vehicle_hov_occupancy', 'vehicle_license_plate', 'vehicle_speed_cap', 'vehicle_type', 'ev_traffic_speed_table', 'ev_ascent', 'ev_descent', 'ev_auxiliary_consumption', 'ev_initial_charge', 'ev_max_charge', 'ev_charging_curve', 'ev_max_charging_voltage', 'ev_max_charging_current', 'ev_max_charge_after_charging_station', 'ev_min_charge_at_charging_station', 'ev_min_charge_at_first_charging_station', 'ev_min_charge_at_destination', 'ev_charging_setup_duration', 'ev_connector_types', 'scooter_allow_highway', 'taxi_allow_drive_through_taxi_roads']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_route" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transport_mode' is set
        if ('transport_mode' not in params or
                params['transport_mode'] is None):
            raise ValueError("Missing the required parameter `transport_mode` when calling `import_route`")  # noqa: E501
        # verify the required parameter 'ev_free_flow_speed_table' is set
        if ('ev_free_flow_speed_table' not in params or
                params['ev_free_flow_speed_table'] is None):
            raise ValueError("Missing the required parameter `ev_free_flow_speed_table` when calling `import_route`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'transport_mode' in params:
            query_params.append(('transportMode', params['transport_mode']))  # noqa: E501
        if 'departure_time' in params:
            query_params.append(('departureTime', params['departure_time']))  # noqa: E501
        if 'avoid_features' in params:
            query_params.append(('avoid[features]', params['avoid_features']))  # noqa: E501
        if 'avoid_areas' in params:
            query_params.append(('avoid[areas]', params['avoid_areas']))  # noqa: E501
        if 'avoid_segments' in params:
            query_params.append(('avoid[segments]', params['avoid_segments']))  # noqa: E501
        if 'avoid_zone_categories' in params:
            query_params.append(('avoid[zoneCategories]', params['avoid_zone_categories']))  # noqa: E501
        if 'avoid_zone_identifiers' in params:
            query_params.append(('avoid[zoneIdentifiers]', params['avoid_zone_identifiers']))  # noqa: E501
        if 'avoid_truck_road_types' in params:
            query_params.append(('avoid[truckRoadTypes]', params['avoid_truck_road_types']))  # noqa: E501
        if 'avoid_toll_transponders' in params:
            query_params.append(('avoid[tollTransponders]', params['avoid_toll_transponders']))  # noqa: E501
        if 'exclude_countries' in params:
            query_params.append(('exclude[countries]', params['exclude_countries']))  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501
            collection_formats['lang'] = 'csv'  # noqa: E501
        if '_return' in params:
            query_params.append(('return', params['_return']))  # noqa: E501
            collection_formats['return'] = 'csv'  # noqa: E501
        if 'spans' in params:
            query_params.append(('spans', params['spans']))  # noqa: E501
            collection_formats['spans'] = 'csv'  # noqa: E501
        if 'truck_shipped_hazardous_goods' in params:
            query_params.append(('truck[shippedHazardousGoods]', params['truck_shipped_hazardous_goods']))  # noqa: E501
        if 'truck_gross_weight' in params:
            query_params.append(('truck[grossWeight]', params['truck_gross_weight']))  # noqa: E501
        if 'truck_weight_per_axle' in params:
            query_params.append(('truck[weightPerAxle]', params['truck_weight_per_axle']))  # noqa: E501
        if 'truck_weight_per_axle_group' in params:
            query_params.append(('truck[weightPerAxleGroup]', params['truck_weight_per_axle_group']))  # noqa: E501
        if 'truck_height' in params:
            query_params.append(('truck[height]', params['truck_height']))  # noqa: E501
        if 'truck_width' in params:
            query_params.append(('truck[width]', params['truck_width']))  # noqa: E501
        if 'truck_length' in params:
            query_params.append(('truck[length]', params['truck_length']))  # noqa: E501
        if 'truck_tunnel_category' in params:
            query_params.append(('truck[tunnelCategory]', params['truck_tunnel_category']))  # noqa: E501
        if 'truck_axle_count' in params:
            query_params.append(('truck[axleCount]', params['truck_axle_count']))  # noqa: E501
        if 'truck_trailer_axle_count' in params:
            query_params.append(('truck[trailerAxleCount]', params['truck_trailer_axle_count']))  # noqa: E501
        if 'truck_tires_count' in params:
            query_params.append(('truck[tiresCount]', params['truck_tires_count']))  # noqa: E501
        if 'truck_category' in params:
            query_params.append(('truck[category]', params['truck_category']))  # noqa: E501
        if 'truck_trailer_count' in params:
            query_params.append(('truck[trailerCount]', params['truck_trailer_count']))  # noqa: E501
        if 'truck_hov_occupancy' in params:
            query_params.append(('truck[hovOccupancy]', params['truck_hov_occupancy']))  # noqa: E501
        if 'truck_license_plate' in params:
            query_params.append(('truck[licensePlate]', params['truck_license_plate']))  # noqa: E501
        if 'truck_speed_cap' in params:
            query_params.append(('truck[speedCap]', params['truck_speed_cap']))  # noqa: E501
        if 'truck_type' in params:
            query_params.append(('truck[type]', params['truck_type']))  # noqa: E501
        if 'vehicle_shipped_hazardous_goods' in params:
            query_params.append(('vehicle[shippedHazardousGoods]', params['vehicle_shipped_hazardous_goods']))  # noqa: E501
        if 'vehicle_gross_weight' in params:
            query_params.append(('vehicle[grossWeight]', params['vehicle_gross_weight']))  # noqa: E501
        if 'vehicle_weight_per_axle' in params:
            query_params.append(('vehicle[weightPerAxle]', params['vehicle_weight_per_axle']))  # noqa: E501
        if 'vehicle_weight_per_axle_group' in params:
            query_params.append(('vehicle[weightPerAxleGroup]', params['vehicle_weight_per_axle_group']))  # noqa: E501
        if 'vehicle_height' in params:
            query_params.append(('vehicle[height]', params['vehicle_height']))  # noqa: E501
        if 'vehicle_width' in params:
            query_params.append(('vehicle[width]', params['vehicle_width']))  # noqa: E501
        if 'vehicle_length' in params:
            query_params.append(('vehicle[length]', params['vehicle_length']))  # noqa: E501
        if 'vehicle_tunnel_category' in params:
            query_params.append(('vehicle[tunnelCategory]', params['vehicle_tunnel_category']))  # noqa: E501
        if 'vehicle_axle_count' in params:
            query_params.append(('vehicle[axleCount]', params['vehicle_axle_count']))  # noqa: E501
        if 'vehicle_trailer_axle_count' in params:
            query_params.append(('vehicle[trailerAxleCount]', params['vehicle_trailer_axle_count']))  # noqa: E501
        if 'vehicle_tires_count' in params:
            query_params.append(('vehicle[tiresCount]', params['vehicle_tires_count']))  # noqa: E501
        if 'vehicle_category' in params:
            query_params.append(('vehicle[category]', params['vehicle_category']))  # noqa: E501
        if 'vehicle_trailer_count' in params:
            query_params.append(('vehicle[trailerCount]', params['vehicle_trailer_count']))  # noqa: E501
        if 'vehicle_hov_occupancy' in params:
            query_params.append(('vehicle[hovOccupancy]', params['vehicle_hov_occupancy']))  # noqa: E501
        if 'vehicle_license_plate' in params:
            query_params.append(('vehicle[licensePlate]', params['vehicle_license_plate']))  # noqa: E501
        if 'vehicle_speed_cap' in params:
            query_params.append(('vehicle[speedCap]', params['vehicle_speed_cap']))  # noqa: E501
        if 'vehicle_type' in params:
            query_params.append(('vehicle[type]', params['vehicle_type']))  # noqa: E501
        if 'ev_free_flow_speed_table' in params:
            query_params.append(('ev[freeFlowSpeedTable]', params['ev_free_flow_speed_table']))  # noqa: E501
        if 'ev_traffic_speed_table' in params:
            query_params.append(('ev[trafficSpeedTable]', params['ev_traffic_speed_table']))  # noqa: E501
        if 'ev_ascent' in params:
            query_params.append(('ev[ascent]', params['ev_ascent']))  # noqa: E501
        if 'ev_descent' in params:
            query_params.append(('ev[descent]', params['ev_descent']))  # noqa: E501
        if 'ev_auxiliary_consumption' in params:
            query_params.append(('ev[auxiliaryConsumption]', params['ev_auxiliary_consumption']))  # noqa: E501
        if 'ev_initial_charge' in params:
            query_params.append(('ev[initialCharge]', params['ev_initial_charge']))  # noqa: E501
        if 'ev_max_charge' in params:
            query_params.append(('ev[maxCharge]', params['ev_max_charge']))  # noqa: E501
        if 'ev_charging_curve' in params:
            query_params.append(('ev[chargingCurve]', params['ev_charging_curve']))  # noqa: E501
        if 'ev_max_charging_voltage' in params:
            query_params.append(('ev[maxChargingVoltage]', params['ev_max_charging_voltage']))  # noqa: E501
        if 'ev_max_charging_current' in params:
            query_params.append(('ev[maxChargingCurrent]', params['ev_max_charging_current']))  # noqa: E501
        if 'ev_max_charge_after_charging_station' in params:
            query_params.append(('ev[maxChargeAfterChargingStation]', params['ev_max_charge_after_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_charging_station' in params:
            query_params.append(('ev[minChargeAtChargingStation]', params['ev_min_charge_at_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_first_charging_station' in params:
            query_params.append(('ev[minChargeAtFirstChargingStation]', params['ev_min_charge_at_first_charging_station']))  # noqa: E501
        if 'ev_min_charge_at_destination' in params:
            query_params.append(('ev[minChargeAtDestination]', params['ev_min_charge_at_destination']))  # noqa: E501
        if 'ev_charging_setup_duration' in params:
            query_params.append(('ev[chargingSetupDuration]', params['ev_charging_setup_duration']))  # noqa: E501
        if 'ev_connector_types' in params:
            query_params.append(('ev[connectorTypes]', params['ev_connector_types']))  # noqa: E501
        if 'scooter_allow_highway' in params:
            query_params.append(('scooter[allowHighway]', params['scooter_allow_highway']))  # noqa: E501
        if 'taxi_allow_drive_through_taxi_roads' in params:
            query_params.append(('taxi[allowDriveThroughTaxiRoads]', params['taxi_allow_drive_through_taxi_roads']))  # noqa: E501

        header_params = {}
        if 'x_request_id' in params:
            header_params['X-Request-ID'] = params['x_request_id']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/geo+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKey', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RouterRouteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
