# coding: utf-8

"""
    Routing API v8

    A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.  # noqa: E501

    OpenAPI spec version: 8.52.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class PedestrianSpan(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'offset': 'int',
        'length': 'Distance',
        'duration': 'Duration',
        'street_attributes': 'list[StreetAttributes]',
        'walk_attributes': 'list[WalkAttributes]',
        'car_attributes': 'list[AccessAttributes]',
        'truck_attributes': 'list[AccessAttributes]',
        'scooter_attributes': 'list[AccessAttributes]',
        'names': 'list[LocalizedString]',
        'route_numbers': 'list[LocalizedString]',
        'country_code': 'CountryCode',
        'functional_class': 'FunctionalClass',
        'speed_limit': 'Speed',
        'max_speed': 'MaxSpeed',
        'dynamic_speed_info': 'DynamicSpeedInfo',
        'segment_id': 'str',
        'segment_ref': 'str',
        'base_duration': 'Duration',
        'typical_duration': 'Duration',
        'incidents': 'list[int]'
    }

    attribute_map = {
        'offset': 'offset',
        'length': 'length',
        'duration': 'duration',
        'street_attributes': 'streetAttributes',
        'walk_attributes': 'walkAttributes',
        'car_attributes': 'carAttributes',
        'truck_attributes': 'truckAttributes',
        'scooter_attributes': 'scooterAttributes',
        'names': 'names',
        'route_numbers': 'routeNumbers',
        'country_code': 'countryCode',
        'functional_class': 'functionalClass',
        'speed_limit': 'speedLimit',
        'max_speed': 'maxSpeed',
        'dynamic_speed_info': 'dynamicSpeedInfo',
        'segment_id': 'segmentId',
        'segment_ref': 'segmentRef',
        'base_duration': 'baseDuration',
        'typical_duration': 'typicalDuration',
        'incidents': 'incidents'
    }

    def __init__(self, offset=None, length=None, duration=None, street_attributes=None, walk_attributes=None, car_attributes=None, truck_attributes=None, scooter_attributes=None, names=None, route_numbers=None, country_code=None, functional_class=None, speed_limit=None, max_speed=None, dynamic_speed_info=None, segment_id=None, segment_ref=None, base_duration=None, typical_duration=None, incidents=None):  # noqa: E501
        """PedestrianSpan - a model defined in Swagger"""  # noqa: E501
        self._offset = None
        self._length = None
        self._duration = None
        self._street_attributes = None
        self._walk_attributes = None
        self._car_attributes = None
        self._truck_attributes = None
        self._scooter_attributes = None
        self._names = None
        self._route_numbers = None
        self._country_code = None
        self._functional_class = None
        self._speed_limit = None
        self._max_speed = None
        self._dynamic_speed_info = None
        self._segment_id = None
        self._segment_ref = None
        self._base_duration = None
        self._typical_duration = None
        self._incidents = None
        self.discriminator = None
        if offset is not None:
            self.offset = offset
        if length is not None:
            self.length = length
        if duration is not None:
            self.duration = duration
        if street_attributes is not None:
            self.street_attributes = street_attributes
        if walk_attributes is not None:
            self.walk_attributes = walk_attributes
        if car_attributes is not None:
            self.car_attributes = car_attributes
        if truck_attributes is not None:
            self.truck_attributes = truck_attributes
        if scooter_attributes is not None:
            self.scooter_attributes = scooter_attributes
        if names is not None:
            self.names = names
        if route_numbers is not None:
            self.route_numbers = route_numbers
        if country_code is not None:
            self.country_code = country_code
        if functional_class is not None:
            self.functional_class = functional_class
        if speed_limit is not None:
            self.speed_limit = speed_limit
        if max_speed is not None:
            self.max_speed = max_speed
        if dynamic_speed_info is not None:
            self.dynamic_speed_info = dynamic_speed_info
        if segment_id is not None:
            self.segment_id = segment_id
        if segment_ref is not None:
            self.segment_ref = segment_ref
        if base_duration is not None:
            self.base_duration = base_duration
        if typical_duration is not None:
            self.typical_duration = typical_duration
        if incidents is not None:
            self.incidents = incidents

    @property
    def offset(self):
        """Gets the offset of this PedestrianSpan.  # noqa: E501

        Offset of a coordinate in the section's polyline.   # noqa: E501

        :return: The offset of this PedestrianSpan.  # noqa: E501
        :rtype: int
        """
        return self._offset

    @offset.setter
    def offset(self, offset):
        """Sets the offset of this PedestrianSpan.

        Offset of a coordinate in the section's polyline.   # noqa: E501

        :param offset: The offset of this PedestrianSpan.  # noqa: E501
        :type: int
        """

        self._offset = offset

    @property
    def length(self):
        """Gets the length of this PedestrianSpan.  # noqa: E501


        :return: The length of this PedestrianSpan.  # noqa: E501
        :rtype: Distance
        """
        return self._length

    @length.setter
    def length(self, length):
        """Sets the length of this PedestrianSpan.


        :param length: The length of this PedestrianSpan.  # noqa: E501
        :type: Distance
        """

        self._length = length

    @property
    def duration(self):
        """Gets the duration of this PedestrianSpan.  # noqa: E501


        :return: The duration of this PedestrianSpan.  # noqa: E501
        :rtype: Duration
        """
        return self._duration

    @duration.setter
    def duration(self, duration):
        """Sets the duration of this PedestrianSpan.


        :param duration: The duration of this PedestrianSpan.  # noqa: E501
        :type: Duration
        """

        self._duration = duration

    @property
    def street_attributes(self):
        """Gets the street_attributes of this PedestrianSpan.  # noqa: E501

        `StreetAttributes` is applied to a span of a route section and describes attribute flags of a street. * `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side. * `dirtRoad`: This part of the route has an un-paved surface. * `tunnel`: This part of the route is a tunnel. * `bridge`: This part of the route is a bridge. * `ramp`: This part of the route is a ramp (usually connecting to/from/between highways). * `motorway`: This part of the route is a controlled access road (usually highways with motorway sign). * `roundabout`: This part of the route is a roundabout. * `underConstruction`: This part of the route is under construction. * `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle. * `privateRoad`: This part of the route uses a privately owned road. * `controlledAccessHighway`: This part of the route is a either controlled access or limited access road or both.  As it is possible that new street attributes are supported in the future, unknown street attributes should be ignored.   # noqa: E501

        :return: The street_attributes of this PedestrianSpan.  # noqa: E501
        :rtype: list[StreetAttributes]
        """
        return self._street_attributes

    @street_attributes.setter
    def street_attributes(self, street_attributes):
        """Sets the street_attributes of this PedestrianSpan.

        `StreetAttributes` is applied to a span of a route section and describes attribute flags of a street. * `rightDrivingSide`: Do vehicles have to drive on the right-hand side of the road or the left-hand side. * `dirtRoad`: This part of the route has an un-paved surface. * `tunnel`: This part of the route is a tunnel. * `bridge`: This part of the route is a bridge. * `ramp`: This part of the route is a ramp (usually connecting to/from/between highways). * `motorway`: This part of the route is a controlled access road (usually highways with motorway sign). * `roundabout`: This part of the route is a roundabout. * `underConstruction`: This part of the route is under construction. * `dividedRoad`: This part of the route uses a road with a physical or legal divider in the middle. * `privateRoad`: This part of the route uses a privately owned road. * `controlledAccessHighway`: This part of the route is a either controlled access or limited access road or both.  As it is possible that new street attributes are supported in the future, unknown street attributes should be ignored.   # noqa: E501

        :param street_attributes: The street_attributes of this PedestrianSpan.  # noqa: E501
        :type: list[StreetAttributes]
        """

        self._street_attributes = street_attributes

    @property
    def walk_attributes(self):
        """Gets the walk_attributes of this PedestrianSpan.  # noqa: E501

        Accessibility and walk-related attribute flags.  * `stairs`: This part of the route is a staircase. * `park`: This part of the route is in a park. * `indoor`: This part of the route is inside a venue. * `open`: This part of the route is open to walking. * `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new attributes are supported in the future, unknown attributes should be ignored.   # noqa: E501

        :return: The walk_attributes of this PedestrianSpan.  # noqa: E501
        :rtype: list[WalkAttributes]
        """
        return self._walk_attributes

    @walk_attributes.setter
    def walk_attributes(self, walk_attributes):
        """Sets the walk_attributes of this PedestrianSpan.

        Accessibility and walk-related attribute flags.  * `stairs`: This part of the route is a staircase. * `park`: This part of the route is in a park. * `indoor`: This part of the route is inside a venue. * `open`: This part of the route is open to walking. * `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new attributes are supported in the future, unknown attributes should be ignored.   # noqa: E501

        :param walk_attributes: The walk_attributes of this PedestrianSpan.  # noqa: E501
        :type: list[WalkAttributes]
        """

        self._walk_attributes = walk_attributes

    @property
    def car_attributes(self):
        """Gets the car_attributes of this PedestrianSpan.  # noqa: E501

        Car specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  A part of the route that is open to cars. * `noThrough`:  A part of the route that can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :return: The car_attributes of this PedestrianSpan.  # noqa: E501
        :rtype: list[AccessAttributes]
        """
        return self._car_attributes

    @car_attributes.setter
    def car_attributes(self, car_attributes):
        """Sets the car_attributes of this PedestrianSpan.

        Car specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`:  A part of the route that is open to cars. * `noThrough`:  A part of the route that can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: Access to this part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :param car_attributes: The car_attributes of this PedestrianSpan.  # noqa: E501
        :type: list[AccessAttributes]
        """

        self._car_attributes = car_attributes

    @property
    def truck_attributes(self):
        """Gets the truck_attributes of this PedestrianSpan.  # noqa: E501

        Truck specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`: This part of the route is open to trucks. * `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: This part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :return: The truck_attributes of this PedestrianSpan.  # noqa: E501
        :rtype: list[AccessAttributes]
        """
        return self._truck_attributes

    @truck_attributes.setter
    def truck_attributes(self, truck_attributes):
        """Sets the truck_attributes of this PedestrianSpan.

        Truck specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`: This part of the route is open to trucks. * `noThrough`: This part of the route can only be traversed if origin, destination or any via waypoint is located there. * `tollRoad`: This part of the route is restricted with a fee (or toll).  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :param truck_attributes: The truck_attributes of this PedestrianSpan.  # noqa: E501
        :type: list[AccessAttributes]
        """

        self._truck_attributes = truck_attributes

    @property
    def scooter_attributes(self):
        """Gets the scooter_attributes of this PedestrianSpan.  # noqa: E501

        Scooter specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`: This part of the route is open to scooters.  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :return: The scooter_attributes of this PedestrianSpan.  # noqa: E501
        :rtype: list[AccessAttributes]
        """
        return self._scooter_attributes

    @scooter_attributes.setter
    def scooter_attributes(self, scooter_attributes):
        """Sets the scooter_attributes of this PedestrianSpan.

        Scooter specific `AccessAttributes`.  `AccessAttributes` is applied to a span of a route section and describes access flags of a street. * `open`: This part of the route is open to scooters.  As it is possible that new access attributes are supported in the future, unknown access attributes should be ignored.   # noqa: E501

        :param scooter_attributes: The scooter_attributes of this PedestrianSpan.  # noqa: E501
        :type: list[AccessAttributes]
        """

        self._scooter_attributes = scooter_attributes

    @property
    def names(self):
        """Gets the names of this PedestrianSpan.  # noqa: E501

        Designated name for the span (e.g. a street name or a transport name)  # noqa: E501

        :return: The names of this PedestrianSpan.  # noqa: E501
        :rtype: list[LocalizedString]
        """
        return self._names

    @names.setter
    def names(self, names):
        """Sets the names of this PedestrianSpan.

        Designated name for the span (e.g. a street name or a transport name)  # noqa: E501

        :param names: The names of this PedestrianSpan.  # noqa: E501
        :type: list[LocalizedString]
        """

        self._names = names

    @property
    def route_numbers(self):
        """Gets the route_numbers of this PedestrianSpan.  # noqa: E501

        Designated route name or number of the span (e.g. 'M25')  # noqa: E501

        :return: The route_numbers of this PedestrianSpan.  # noqa: E501
        :rtype: list[LocalizedString]
        """
        return self._route_numbers

    @route_numbers.setter
    def route_numbers(self, route_numbers):
        """Sets the route_numbers of this PedestrianSpan.

        Designated route name or number of the span (e.g. 'M25')  # noqa: E501

        :param route_numbers: The route_numbers of this PedestrianSpan.  # noqa: E501
        :type: list[LocalizedString]
        """

        self._route_numbers = route_numbers

    @property
    def country_code(self):
        """Gets the country_code of this PedestrianSpan.  # noqa: E501


        :return: The country_code of this PedestrianSpan.  # noqa: E501
        :rtype: CountryCode
        """
        return self._country_code

    @country_code.setter
    def country_code(self, country_code):
        """Sets the country_code of this PedestrianSpan.


        :param country_code: The country_code of this PedestrianSpan.  # noqa: E501
        :type: CountryCode
        """

        self._country_code = country_code

    @property
    def functional_class(self):
        """Gets the functional_class of this PedestrianSpan.  # noqa: E501


        :return: The functional_class of this PedestrianSpan.  # noqa: E501
        :rtype: FunctionalClass
        """
        return self._functional_class

    @functional_class.setter
    def functional_class(self, functional_class):
        """Sets the functional_class of this PedestrianSpan.


        :param functional_class: The functional_class of this PedestrianSpan.  # noqa: E501
        :type: FunctionalClass
        """

        self._functional_class = functional_class

    @property
    def speed_limit(self):
        """Gets the speed_limit of this PedestrianSpan.  # noqa: E501


        :return: The speed_limit of this PedestrianSpan.  # noqa: E501
        :rtype: Speed
        """
        return self._speed_limit

    @speed_limit.setter
    def speed_limit(self, speed_limit):
        """Sets the speed_limit of this PedestrianSpan.


        :param speed_limit: The speed_limit of this PedestrianSpan.  # noqa: E501
        :type: Speed
        """

        self._speed_limit = speed_limit

    @property
    def max_speed(self):
        """Gets the max_speed of this PedestrianSpan.  # noqa: E501


        :return: The max_speed of this PedestrianSpan.  # noqa: E501
        :rtype: MaxSpeed
        """
        return self._max_speed

    @max_speed.setter
    def max_speed(self, max_speed):
        """Sets the max_speed of this PedestrianSpan.


        :param max_speed: The max_speed of this PedestrianSpan.  # noqa: E501
        :type: MaxSpeed
        """

        self._max_speed = max_speed

    @property
    def dynamic_speed_info(self):
        """Gets the dynamic_speed_info of this PedestrianSpan.  # noqa: E501


        :return: The dynamic_speed_info of this PedestrianSpan.  # noqa: E501
        :rtype: DynamicSpeedInfo
        """
        return self._dynamic_speed_info

    @dynamic_speed_info.setter
    def dynamic_speed_info(self, dynamic_speed_info):
        """Sets the dynamic_speed_info of this PedestrianSpan.


        :param dynamic_speed_info: The dynamic_speed_info of this PedestrianSpan.  # noqa: E501
        :type: DynamicSpeedInfo
        """

        self._dynamic_speed_info = dynamic_speed_info

    @property
    def segment_id(self):
        """Gets the segment_id of this PedestrianSpan.  # noqa: E501

        **Disclaimer: This property is currently in beta release, and is therefore subject to breaking changes.**  The directed topology segment id including prefix (e.g '+here:cm:segment:').  The id consists of two parts. * The direction ('+' or '-') * followed by the topology segment id (a unique identifier within the HERE platform catalogs).  The direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction).   # noqa: E501

        :return: The segment_id of this PedestrianSpan.  # noqa: E501
        :rtype: str
        """
        return self._segment_id

    @segment_id.setter
    def segment_id(self, segment_id):
        """Sets the segment_id of this PedestrianSpan.

        **Disclaimer: This property is currently in beta release, and is therefore subject to breaking changes.**  The directed topology segment id including prefix (e.g '+here:cm:segment:').  The id consists of two parts. * The direction ('+' or '-') * followed by the topology segment id (a unique identifier within the HERE platform catalogs).  The direction specifies whether the route is using the segment in its canonical direction ('+' aka traveling along the geometry's direction), or against it ('-' aka traveling against the geometry's direction).   # noqa: E501

        :param segment_id: The segment_id of this PedestrianSpan.  # noqa: E501
        :type: str
        """

        self._segment_id = segment_id

    @property
    def segment_ref(self):
        """Gets the segment_ref of this PedestrianSpan.  # noqa: E501

        A reference to the HMC topology segment used in this span.  The standard representation of a segment reference has the following structure: {catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?  The individual parts are: * catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2 * catalogVersion: The catalog version * layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry * tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexidecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>) * segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195 * direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service) * startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1  Example of a segment reference in standard representation: hrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1  The segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section. The placeholder format is \\$\\d+ and need to be surrounded by columns or string start/end. It can be captured with the following regular expression: (^|:)\\$\\d+(:|$)  Example of the segment reference previously mentioned in compact representation: $0:377894441:$1:84905195#+0.7..1 With the corresponding refReplacements: \"refReplacements\": {   \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",   \"1\": \"here:cm:segment\" }   # noqa: E501

        :return: The segment_ref of this PedestrianSpan.  # noqa: E501
        :rtype: str
        """
        return self._segment_ref

    @segment_ref.setter
    def segment_ref(self, segment_ref):
        """Sets the segment_ref of this PedestrianSpan.

        A reference to the HMC topology segment used in this span.  The standard representation of a segment reference has the following structure: {catalogHrn}:{catalogVersion}:({layerId})?:{tileId}:{segmentId}(#{direction}({startOffset}..{endOffset})?)?  The individual parts are: * catalogHrn: The HERE Resource Name that identifies the source catalog of the segment, example: hrn:here:data::olp-here:rib-2 * catalogVersion: The catalog version * layerId (optional): The layer inside the catalog where the segment can be found, example: topology-geometry * tileId: The HERE tile key of the partition/tile where the segment is located in the given version of the catalog. This can be on a lower level than the actual segment is stored at (for example, the provided tile ID can be on level 14, despite topology-geometry partitions being tiled at level 12). The level of a HERE tile key is indicated by the position of the highest set bit in binary representation. Since the HERE tile key represents a morton code of the x and y portion of the Tile ID, the level 12 tile ID can be retrieved from the level 14 tile ID by removing the 4 least significant bits (or 2 bits per level) or 1 hexidecimal digit. For example, the level 14 tile 377894441 is included in the level 12 tile 23618402 (377894441<sub>10</sub> = 16863629<sub>16</sub> &rightarrow; 1686362<sub>16</sub> = 23618402<sub>10</sub>) * segmentId: The identifier of the referenced topology segment inside the catalog, example: here:cm:segment:84905195 * direction (optional): Either '*' for undirected or bidirectional, '+' for positive direction, '-' for negative direction, or '?' for unknown direction (not used by the routing service) * startOffset/endOffset (optional): The start- and end offset are non-negative numbers between 0 and 1, representing the start and end of the referenced range using a proportion of the length of the segment. 0 represents the start and 1 the end of the segment, relative to the indicated direction (or positive direction in case of undirected segments). Example: 0.7..1  Example of a segment reference in standard representation: hrn:here:data::olp-here:rib-2:1363::377894441:here:cm:segment:84905195#+0.7..1  The segment references can also be provided in a compact representation, to reduce the response size. In the compact representation, some parts are replaced by placeholders, which can be resolved using the refReplacements dictionary in the parent section. The placeholder format is \\$\\d+ and need to be surrounded by columns or string start/end. It can be captured with the following regular expression: (^|:)\\$\\d+(:|$)  Example of the segment reference previously mentioned in compact representation: $0:377894441:$1:84905195#+0.7..1 With the corresponding refReplacements: \"refReplacements\": {   \"0\": \"hrn:here:data::olp-here:rib-2:1363:\",   \"1\": \"here:cm:segment\" }   # noqa: E501

        :param segment_ref: The segment_ref of this PedestrianSpan.  # noqa: E501
        :type: str
        """

        self._segment_ref = segment_ref

    @property
    def base_duration(self):
        """Gets the base_duration of this PedestrianSpan.  # noqa: E501


        :return: The base_duration of this PedestrianSpan.  # noqa: E501
        :rtype: Duration
        """
        return self._base_duration

    @base_duration.setter
    def base_duration(self, base_duration):
        """Sets the base_duration of this PedestrianSpan.


        :param base_duration: The base_duration of this PedestrianSpan.  # noqa: E501
        :type: Duration
        """

        self._base_duration = base_duration

    @property
    def typical_duration(self):
        """Gets the typical_duration of this PedestrianSpan.  # noqa: E501


        :return: The typical_duration of this PedestrianSpan.  # noqa: E501
        :rtype: Duration
        """
        return self._typical_duration

    @typical_duration.setter
    def typical_duration(self, typical_duration):
        """Sets the typical_duration of this PedestrianSpan.


        :param typical_duration: The typical_duration of this PedestrianSpan.  # noqa: E501
        :type: Duration
        """

        self._typical_duration = typical_duration

    @property
    def incidents(self):
        """Gets the incidents of this PedestrianSpan.  # noqa: E501

        A list of indices into the incident array of the parent section. References all incidents that apply to the span.   # noqa: E501

        :return: The incidents of this PedestrianSpan.  # noqa: E501
        :rtype: list[int]
        """
        return self._incidents

    @incidents.setter
    def incidents(self, incidents):
        """Sets the incidents of this PedestrianSpan.

        A list of indices into the incident array of the parent section. References all incidents that apply to the span.   # noqa: E501

        :param incidents: The incidents of this PedestrianSpan.  # noqa: E501
        :type: list[int]
        """

        self._incidents = incidents

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PedestrianSpan, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PedestrianSpan):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
