# coding: utf-8

"""
    Routing API v8

    A location service providing customizable route calculations for a variety of vehicle types as well as pedestrian modes.  # noqa: E501

    OpenAPI spec version: 8.52.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Avoid(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'features': 'str',
        'areas': 'str',
        'segments': 'str',
        'zone_categories': 'str',
        'zone_identifiers': 'str',
        'truck_road_types': 'str',
        'toll_transponders': 'str'
    }

    attribute_map = {
        'features': 'features',
        'areas': 'areas',
        'segments': 'segments',
        'zone_categories': 'zoneCategories',
        'zone_identifiers': 'zoneIdentifiers',
        'truck_road_types': 'truckRoadTypes',
        'toll_transponders': 'tollTransponders'
    }

    def __init__(self, features=None, areas=None, segments=None, zone_categories=None, zone_identifiers=None, truck_road_types=None, toll_transponders=None):  # noqa: E501
        """Avoid - a model defined in Swagger"""  # noqa: E501
        self._features = None
        self._areas = None
        self._segments = None
        self._zone_categories = None
        self._zone_identifiers = None
        self._truck_road_types = None
        self._toll_transponders = None
        self.discriminator = None
        if features is not None:
            self.features = features
        if areas is not None:
            self.areas = areas
        if segments is not None:
            self.segments = segments
        if zone_categories is not None:
            self.zone_categories = zone_categories
        if zone_identifiers is not None:
            self.zone_identifiers = zone_identifiers
        if truck_road_types is not None:
            self.truck_road_types = truck_road_types
        if toll_transponders is not None:
            self.toll_transponders = toll_transponders

    @property
    def features(self):
        """Gets the features of this Avoid.  # noqa: E501

        A comma separated list of features that routes will avoid.  * `seasonalClosure` * `tollRoad` * `controlledAccessHighway` * `ferry` * `carShuttleTrain` * `tunnel` * `dirtRoad` * `difficultTurns`: This option avoids difficult turns, sharp turns and U-turns on highways and motorways. It is only supported for the `truck` transport mode. * `uTurns`: This option avoids U-turns on highways and motorways. It is only supported for the `truck` transport mode.   # noqa: E501

        :return: The features of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._features

    @features.setter
    def features(self, features):
        """Sets the features of this Avoid.

        A comma separated list of features that routes will avoid.  * `seasonalClosure` * `tollRoad` * `controlledAccessHighway` * `ferry` * `carShuttleTrain` * `tunnel` * `dirtRoad` * `difficultTurns`: This option avoids difficult turns, sharp turns and U-turns on highways and motorways. It is only supported for the `truck` transport mode. * `uTurns`: This option avoids U-turns on highways and motorways. It is only supported for the `truck` transport mode.   # noqa: E501

        :param features: The features of this Avoid.  # noqa: E501
        :type: str
        """

        self._features = features

    @property
    def areas(self):
        """Gets the areas of this Avoid.  # noqa: E501

        A pipe separated list of user defined areas that routes will avoid to go through. The list is limited by 250 items.  Format: `{shape1}|{shape2}|{shape3}...`  Supported shape format: * Bounding box - A rectangular area on earth defined by a comma separated list of two latitude and two longitude values.   - Format: `bbox:{west},{south},{east},{north}`     + `{west}`  - Longitude value of the westernmost point of the area.     + `{south}` - Latitude value of the southernmost point of the area.     + `{east}`  - Longitude value of the easternmost point of the area.     + `{north}` - Latitude value of the northernmost point of the area.   - Example: `bbox:13.082,52.416,13.628,52.626` - Bounding box of Berlin   # noqa: E501

        :return: The areas of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._areas

    @areas.setter
    def areas(self, areas):
        """Sets the areas of this Avoid.

        A pipe separated list of user defined areas that routes will avoid to go through. The list is limited by 250 items.  Format: `{shape1}|{shape2}|{shape3}...`  Supported shape format: * Bounding box - A rectangular area on earth defined by a comma separated list of two latitude and two longitude values.   - Format: `bbox:{west},{south},{east},{north}`     + `{west}`  - Longitude value of the westernmost point of the area.     + `{south}` - Latitude value of the southernmost point of the area.     + `{east}`  - Longitude value of the easternmost point of the area.     + `{north}` - Latitude value of the northernmost point of the area.   - Example: `bbox:13.082,52.416,13.628,52.626` - Bounding box of Berlin   # noqa: E501

        :param areas: The areas of this Avoid.  # noqa: E501
        :type: str
        """

        self._areas = areas

    @property
    def segments(self):
        """Gets the segments of this Avoid.  # noqa: E501

        A comma separated list of segment identifiers that routes will avoid going through.  Each entry has the following structure: `{segmentId}(#{direction})?`  The individual parts are: * segmentId: The identifier of the referenced topology segment inside the catalog, example: `here:cm:segment:207551710` * direction (optional): Either '*' for bidirectional (default), '+' for positive direction, or '-' for negative direction  Example of a parameter value excluding two segments: `here:cm:segment:207551710#+,here:cm:segment:76771992#*`  **Note**: Maximum amount of penalized segments in one request should not be grater than 250.           A \"penalized segments\" refers to segments that have a restrictions on maximum baseSpeed with `maxSpeedOnSegment`           or avoided with `avoid[segments]`   # noqa: E501

        :return: The segments of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._segments

    @segments.setter
    def segments(self, segments):
        """Sets the segments of this Avoid.

        A comma separated list of segment identifiers that routes will avoid going through.  Each entry has the following structure: `{segmentId}(#{direction})?`  The individual parts are: * segmentId: The identifier of the referenced topology segment inside the catalog, example: `here:cm:segment:207551710` * direction (optional): Either '*' for bidirectional (default), '+' for positive direction, or '-' for negative direction  Example of a parameter value excluding two segments: `here:cm:segment:207551710#+,here:cm:segment:76771992#*`  **Note**: Maximum amount of penalized segments in one request should not be grater than 250.           A \"penalized segments\" refers to segments that have a restrictions on maximum baseSpeed with `maxSpeedOnSegment`           or avoided with `avoid[segments]`   # noqa: E501

        :param segments: The segments of this Avoid.  # noqa: E501
        :type: str
        """

        self._segments = segments

    @property
    def zone_categories(self):
        """Gets the zone_categories of this Avoid.  # noqa: E501

        Specifies a list of categories of zones which routes will avoid going through.  Format: `Categories[ZoneCategoryOptions]`  * Categories: `{cat1},{cat2}...`   A comma separated list of zone categories. * ZoneCategoriesOptions (optional): `;option1=value1;options2=value2...`   A list of options for zone categories in `KEY=VALUE` form.  Supported zone category options:   * exceptZoneIds: A comma-separated list of zone identifiers, which will not be taken into account for evaluation of zone categories to avoid.  Supported zone categories:   * `vignette`   * `congestionPricing`   * `environmental`  Example of zone categories avoidance: `avoid[zoneCategories]=environmental,vignette`  Example of zone categories avoidance with exceptions: `avoid[zoneCategories]=environmental,vignette;exceptZoneIds=here:cm:envzone:3`   # noqa: E501

        :return: The zone_categories of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._zone_categories

    @zone_categories.setter
    def zone_categories(self, zone_categories):
        """Sets the zone_categories of this Avoid.

        Specifies a list of categories of zones which routes will avoid going through.  Format: `Categories[ZoneCategoryOptions]`  * Categories: `{cat1},{cat2}...`   A comma separated list of zone categories. * ZoneCategoriesOptions (optional): `;option1=value1;options2=value2...`   A list of options for zone categories in `KEY=VALUE` form.  Supported zone category options:   * exceptZoneIds: A comma-separated list of zone identifiers, which will not be taken into account for evaluation of zone categories to avoid.  Supported zone categories:   * `vignette`   * `congestionPricing`   * `environmental`  Example of zone categories avoidance: `avoid[zoneCategories]=environmental,vignette`  Example of zone categories avoidance with exceptions: `avoid[zoneCategories]=environmental,vignette;exceptZoneIds=here:cm:envzone:3`   # noqa: E501

        :param zone_categories: The zone_categories of this Avoid.  # noqa: E501
        :type: str
        """

        self._zone_categories = zone_categories

    @property
    def zone_identifiers(self):
        """Gets the zone_identifiers of this Avoid.  # noqa: E501

        A comma separated list containing identifiers of zones that routes will avoid going through.  Example of an identifier referencing an environmental zone: `here:cm:envzone:2`   # noqa: E501

        :return: The zone_identifiers of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._zone_identifiers

    @zone_identifiers.setter
    def zone_identifiers(self, zone_identifiers):
        """Sets the zone_identifiers of this Avoid.

        A comma separated list containing identifiers of zones that routes will avoid going through.  Example of an identifier referencing an environmental zone: `here:cm:envzone:2`   # noqa: E501

        :param zone_identifiers: The zone_identifiers of this Avoid.  # noqa: E501
        :type: str
        """

        self._zone_identifiers = zone_identifiers

    @property
    def truck_road_types(self):
        """Gets the truck_road_types of this Avoid.  # noqa: E501

        A comma-separated list of truck road type identifiers to be avoided.  A truck road type is an identifier associated with roads that have additional regulations applied by local administration for traversal by heavy vehicles like trucks. For example, the BK Bearing Class regulations in Sweden, and ET categories in Mexico. Identifiers for supported truck road types are specified at HERE Map Content [TruckRoadType](https://developer.here.com/documentation/here-map-content/dev_guide/topics_schema/truckroadtypeattribute.truckroadtype.html).  Example: `avoid[truckRoadTypes]=BK1,BK2,BK3,BK4`   # noqa: E501

        :return: The truck_road_types of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._truck_road_types

    @truck_road_types.setter
    def truck_road_types(self, truck_road_types):
        """Sets the truck_road_types of this Avoid.

        A comma-separated list of truck road type identifiers to be avoided.  A truck road type is an identifier associated with roads that have additional regulations applied by local administration for traversal by heavy vehicles like trucks. For example, the BK Bearing Class regulations in Sweden, and ET categories in Mexico. Identifiers for supported truck road types are specified at HERE Map Content [TruckRoadType](https://developer.here.com/documentation/here-map-content/dev_guide/topics_schema/truckroadtypeattribute.truckroadtype.html).  Example: `avoid[truckRoadTypes]=BK1,BK2,BK3,BK4`   # noqa: E501

        :param truck_road_types: The truck_road_types of this Avoid.  # noqa: E501
        :type: str
        """

        self._truck_road_types = truck_road_types

    @property
    def toll_transponders(self):
        """Gets the toll_transponders of this Avoid.  # noqa: E501

        Indicates that routes will avoid all toll transponders.  Example: `avoid[tollTransponders]=all`   # noqa: E501

        :return: The toll_transponders of this Avoid.  # noqa: E501
        :rtype: str
        """
        return self._toll_transponders

    @toll_transponders.setter
    def toll_transponders(self, toll_transponders):
        """Sets the toll_transponders of this Avoid.

        Indicates that routes will avoid all toll transponders.  Example: `avoid[tollTransponders]=all`   # noqa: E501

        :param toll_transponders: The toll_transponders of this Avoid.  # noqa: E501
        :type: str
        """

        self._toll_transponders = toll_transponders

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Avoid, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Avoid):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
